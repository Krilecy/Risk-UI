App.css:
========

html {
	overflow: scroll;
}

.App {
  text-align: center;
}

.GameBoard {
  margin: 20px;
}

h1 {
  font-size: 2rem;
}

h2,
h3,
h4 {
  margin: 10px 0;
}

p {
  margin: 5px 0;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin: 5px 0;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
}


App.js:
=======

import React from 'react';
import './App.css';
import GameBoard from './GameBoard';

function App() {
  return (
    <div className="App">
      <GameBoard />
    </div>
  );
}

export default App;


GameBoard.css:
==============

.game-container {
    display: flex;
    flex-direction: row;
    height: 100vh; /* Make the container take full viewport height */
}

.left-column {
    flex: 1; /* Take up available space */
    padding: 20px;
    display: flex;
    flex-direction: column;
}

.right-column {
    width: 160px;
    padding-right: 20px;
    padding-top: 20px;
    text-align: left;
    overflow-y: auto; /* Add scroll if content overflows */
}

.header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px; /* Add some space below the header */
}

.watch-mode-toggle {
    font-size: 1rem;
}

.map-container {
    flex: 1; /* Take up remaining space in the left column */
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
}

.risk-map {
    width: 100%;
    height: auto; /* Maintain aspect ratio */
    max-width: 100%;
    max-height: 100%;
    margin-left: -200px;
}

.risk-map text {
    font-size: 12px;
    fill: black;
    text-anchor: middle;
}


GameBoard.js:
=============

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import PossibleActions from './PossibleActions';
import './GameBoard.css';
import { ReactComponent as RiskMap } from './classic_map.svg';

const playerColors = ['red', 'lightblue', 'lightgreen', 'yellow', 'pink', 'orange'];

// Predefined positions for each territory with slightly reduced scaling
const territoryPositions = {
    "Alaska": { x: 85, y: 60 },
    "Northwest Territory": { x: 190, y: 60 },
    "Greenland": { x: 460, y: 20 },
    "Alberta": { x: 240, y: 105 },
    "Ontario": { x: 160, y: 105 },
    "Quebec": { x: 320, y: 110 },
    "Western United States": { x: 115, y: 165 },
    "Eastern United States": { x: 240, y: 195 },
    "Central America": { x: 160, y: 265 },
    "Venezuela": { x: 270, y: 315 },
    "Peru": { x: 270, y: 415 },
    "Brazil": { x: 340, y: 385 },
    "Argentina": { x: 290, y: 505 },
    "North Africa": { x: 550, y: 265 },
    "Egypt": { x: 640, y: 225 },
    "East Africa": { x: 720, y: 305 },
    "Congo": { x: 640, y: 355 },
    "South Africa": { x: 655, y: 435 },
    "Madagascar": { x: 750, y: 475 },
    "Western Europe": { x: 520, y: 145 },
    "Southern Europe": { x: 635, y: 155 },
    "Northern Europe": { x: 620, y: 120 },
    "Great Britain": { x: 520, y: 110 },
    "Scandinavia": { x: 610, y: 65 },
    "Ukraine": { x: 695, y: 105 },
    "Iceland": { x: 490, y: 75 },
    "Middle East": { x: 745, y: 195 },
    "Afghanistan": { x: 810, y: 135 },
    "Ural": { x: 800, y: 75 },
    "Siberia": { x: 865, y: 55 },
    "Yakutsk": { x: 970, y: 65 },
    "Irkutsk": { x: 950, y: 105 },
    "Kamchatka": { x: 1100, y: 65 },
    "Mongolia": { x: 970, y: 145 },
    "Japan": { x: 1135, y: 185 },
    "China": { x: 980, y: 205 },
    "India": { x: 880, y: 235 },
    "Siam": { x: 970, y: 265 },
    "Indonesia": { x: 1030, y: 345 },
    "New Guinea": { x: 1150, y: 345 },
    "Western Australia": { x: 1000, y: 465 },
    "Eastern Australia": { x: 1130, y: 445 }
};

const GameBoard = () => {
    const [gameState, setGameState] = useState(null);
    const [error, setError] = useState(null);
    const [watchMode, setWatchMode] = useState(false);

    const fetchGameState = () => {
        axios
            .get('http://localhost:8000/game-state')
            .then((response) => {
                setGameState(response.data.game_state);
                setError(response.data.error);
            })
            .catch((error) => {
                setError(error.message);
            });
    };

    useEffect(() => {
        fetchGameState();
    }, []);

    useEffect(() => {
        if (watchMode) {
            const interval = setInterval(() => {
                fetchGameState();
            }, 250);

            return () => clearInterval(interval);
        }
    }, [watchMode]);

    const toggleWatchMode = () => {
        setWatchMode(!watchMode);
    };

    useEffect(() => {
        if (gameState) {
            // Get the root SVG element or a group element where text will be appended
            const svgElement = document.querySelector('.risk-map');
            if (!svgElement) {
                console.error('SVG element not found.');
                return;
            }
    
            // Clear any existing text elements
            svgElement.querySelectorAll('text, circle').forEach(el => el.remove());
    
            gameState.players.forEach((player, playerIndex) => {
                player.territories.forEach((territory) => {
                    // Use attribute selector to handle IDs with spaces
                    const territoryElements = document.querySelectorAll(`[id="${territory}"]`);
    
                    if (territoryElements.length > 0) {
                        territoryElements.forEach((territoryElement) => {
                            console.log(`Updating territory: ${territory}`);
                            territoryElement.setAttribute('fill', playerColors[playerIndex % playerColors.length]);
                            territoryElement.setAttribute('stroke', 'white');
                            territoryElement.setAttribute('stroke-width', '1');
                        });
    
                        // Use predefined positions for the text
                        const position = territoryPositions[territory];
                        if (position) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', position.x);
                            text.setAttribute('y', position.y);
                            text.setAttribute('fill', 'black');
                            text.setAttribute('font-size', '12');
                            text.setAttribute('font-weight', '600');
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('dominant-baseline', 'middle');
                            
                            // Create tspan elements for line breaks
                            const tspan1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            tspan1.setAttribute('x', position.x);
                            tspan1.setAttribute('dy', '1.2em'); // Vertical offset for first line
                            tspan1.textContent = territory;
    
                            const tspan2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            tspan2.setAttribute('x', position.x);
                            tspan2.setAttribute('dy', '1.2em'); // Vertical offset for second line
                            tspan2.textContent = player.armies[territory];
    
                            text.appendChild(tspan1);
                            text.appendChild(tspan2);
                            
                            // Append the text element to the SVG
                            svgElement.appendChild(text);
                            console.log(`Appended text: ${territory} (${player.armies[territory]})`);
                        } else {
                            console.warn(`Position not defined for territory: ${territory}`);
                        }
                    } else {
                        console.warn(`Territory not found: ${territory}`);
                    }
                });
            });
        }
    }, [gameState]);

    if (error) {
        return <div>Error: {error}</div>;
    }

    if (!gameState) {
        return <div>Loading...</div>;
    }

    const currentPlayer =
        gameState.players && gameState.players[gameState.current_turn];

    return (
        <div className="game-container">
            <div className="left-column">
                <div className="header">
                    <h2>Round: {gameState.round}</h2>
                    <h2>Active Player: {gameState.current_player}</h2>
                    <h2>Turn Phase: {gameState.turn_phase}</h2>
                    <label className="watch-mode-toggle">
                        <input
                            type="checkbox"
                            checked={watchMode}
                            onChange={toggleWatchMode}
                        />
                        Observer Mode
                    </label>
                </div>
                <div className="map-container">
                    <RiskMap className="risk-map" />
                </div>
            </div>
            <div className="right-column">
                <div className="game-info">
                    {currentPlayer && (
                        <div className="player-cards">
                            <h3>Current Player's Cards</h3>
                            <ul>
                                {currentPlayer.cards.map((card, index) => (
                                    <li key={index}>
                                        {card.territory
                                            ? `${card.territory} (${card.kind})`
                                            : `(${card.kind})`}
                                    </li>
                                ))}
                            </ul>
                        </div>
                    )}
                    <PossibleActions
                        gameState={gameState}
                        fetchGameState={fetchGameState}
                        setError={setError}
                    />
                </div>
            </div>
        </div>
    );
};

export default GameBoard;


PossibleActions.css:
====================

.actions-container ul {
    list-style-type: none;
    padding: 0;
}

.actions-container li {
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    background-color: #f9f9f9;
}

.actions-container div {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
}

.actions-container label {
    font-weight: bold;
    margin-right: 5px;
}

.actions-container select {
    margin-top: 5px;
    margin-bottom: 10px;
}

.actions-container button {
    align-self: flex-start;
    padding: 5px 10px;
    background-color: #007bff;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.actions-container button:hover {
    background-color: #0056b3;
}

.actions-container .arrow {
    display: block;
    text-align: center;
    margin: 5px 0;
    font-size: 20px;
    line-height: 1;
}


PossibleActions.js:
===================

import React, { useState } from 'react';
import axios from 'axios';
import './PossibleActions.css';

const PossibleActions = ({ gameState, fetchGameState, setError }) => {
    const [numUnits, setNumUnits] = useState(1);

    const handleAction = (action) => {
        let request = null;

        switch (action.type) {
            case 'Reinforce':
                request = axios.post('http://localhost:8000/reinforce', {
                    player_id: gameState.current_turn,
                    territory: action.territory,
                    num_armies: numUnits,
                });
                break;
            case 'Attack':
                request = axios.post('http://localhost:8000/attack', {
                    attacker_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_dice: numUnits,
                });
                break;
            case 'Fortify':
                request = axios.post('http://localhost:8000/fortify', {
                    player_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_armies: numUnits,
                });
                break;
            case 'MoveArmies':
                request = axios.post('http://localhost:8000/move_armies', {
                    player_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_armies: numUnits,
                });
                break;
            case 'TradeCards':
                request = axios.post('http://localhost:8000/trade_cards', {
                    player_id: gameState.current_turn,
                    card_indices: [0, 1, 2], // Replace with selected card indices
                });
                break;
            case 'AdvancePhase':
                request = axios.post('http://localhost:8000/advance_phase');
                break;
            default:
                console.error('Unknown action type:', action.type);
        }

        if (request) {
            request
                .then((response) => {
                    fetchGameState();
                    setNumUnits(1);
                })
                .catch((error) => {
                    setError(error.message);
                });
        }
    };

    return (
        <div className="actions-container">
            <h3>Possible Actions</h3>
            <ul>
                {gameState.possible_actions &&
                    gameState.possible_actions.map((action, index) => {
                        if (action === 'EndPhase') {
                            return (
                                <li key={index}>
                                    <div>
                                        <strong>Action: </strong>End Phase
                                        <button
                                            onClick={() =>
                                                handleAction({
                                                    type: 'AdvancePhase',
                                                })
                                            }
                                        >
                                            Execute
                                        </button>
                                    </div>
                                </li>
                            );
                        }
                        const actionType = Object.keys(action)[0];
                        const actionDetails = action[actionType];
                        return (
                            <li key={index}>
                                <div>
                                    <strong>{actionType}</strong>
                                    {actionType !== 'TradeCards' &&
                                        actionType !== 'EndPhase' && (
                                            <div>
                                                {Object.keys(actionDetails).map(
                                                    (key, idx) => (
                                                        key !== 'max_dice' && key !== 'max_armies' && (
                                                            <div key={idx}>
                                                                {key === 'from' || key === 'to' ? (
                                                                    <span>
                                                                        {actionDetails[key]}
                                                                        {key === 'from' && (
                                                                            <span className="arrow">
                                                                                &darr;
                                                                            </span>
                                                                        )}
                                                                    </span>
                                                                ) : (
                                                                    <span>{actionDetails[key]}</span>
                                                                )}
                                                            </div>
                                                        )
                                                    )
                                                )}
                                            </div>
                                        )}
                                    {(actionType === 'Reinforce' ||
                                        actionType === 'Attack' ||
                                        actionType === 'Fortify' ||
                                        actionType === 'MoveArmies') && (
                                            <div>
                                                <label htmlFor={`numUnits-${index}`}>
                                                    Number of{' '}
                                                    {actionType === 'Attack'
                                                        ? 'Dice'
                                                        : 'Armies'}:{' '}
                                                </label>
                                                <select
                                                    id={`numUnits-${index}`}
                                                    value={numUnits}
                                                    onChange={(e) =>
                                                        setNumUnits(parseInt(e.target.value))
                                                    }
                                                >
                                                    {Array.from(
                                                        {
                                                            length:
                                                                actionType === 'Attack'
                                                                    ? actionDetails.max_dice
                                                                    : actionDetails.max_armies,
                                                        },
                                                        (_, i) => i + 1
                                                    ).map((num) => (
                                                        <option key={num} value={num}>
                                                            {num}
                                                        </option>
                                                    ))}
                                                </select>
                                            </div>
                                        )}
                                    <button
                                        onClick={() =>
                                            handleAction({
                                                ...actionDetails,
                                                type: actionType,
                                            })
                                        }
                                    >
                                        Execute
                                    </button>
                                </div>
                            </li>
                        );
                    })}
            </ul>
        </div>
    );
};

export default PossibleActions;


index.css:
==========

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



index.js:
=========

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);