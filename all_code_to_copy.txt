App.css:
========

html, body {
  overflow: hidden; /* Hide overflow on the body to prevent scrollbars */
  margin: 0;
  padding: 0;
  height: 100%; /* Ensure full height of viewport */
}

.App {
  text-align: center;
  height: 100%; /* Ensure full height of viewport */
  display: flex;
  flex-direction: column;
}

.GameBoard {
  margin: 20px;
}

h1 {
  font-size: 2rem;
}

h2,
h3,
h4 {
  margin: 10px 0;
}

p {
  margin: 5px 0;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin: 5px 0;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #fff;
}


App.js:
=======

import React from 'react';
import './App.css';
import GameBoard from './GameBoard';

function App() {
  return (
    <div className="App">
      <GameBoard />
    </div>
  );
}

export default App;


GameBoard.css:
==============

.game-container {
    display: flex;
    flex-direction: row;
    height: 100%; /* Ensure full height of viewport */
  }

.left-column {
    flex: 1; /* Take up available space */
    padding: 20px;
    display: flex;
    flex-direction: column;
}

.right-column {
    width: 250px;
    padding-right: 20px;
    padding-top: 20px;
    padding-bottom: 20px;
    text-align: left;
    overflow-y: auto; /* Add scroll if content overflows */
    height: 100vh; /* Viewport height minus padding */
    box-sizing: border-box; /* Include padding in height calculation */
}

.header {
    display: grid;
    grid-template-columns: 0.5fr 1fr 1fr 0.5fr; /* Three equal columns */
    align-items: center;
    margin-bottom: 20px; /* Add some space below the header */
}

.header h2 {
    margin: 0; /* Remove default margins */
    text-align: left; /* Align text to the left */
}
.watch-mode-toggle {
    font-size: 1rem;
    margin: 0; /* Remove default margins */
    text-align: left; /* Align text to the left */
}

.map-container {
    flex: 1; /* Take up remaining space in the left column */
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    position: relative;
}

.risk-map {
    width: 100%;
    height: auto;
    max-width: 100%;
    max-height: 100%;
}

.risk-map text {
    font-size: 12px;
    fill: black;
    text-anchor: middle;
}


GameBoard.js:
=============

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import PossibleActions from './PossibleActions';
import './GameBoard.css';
import { ReactComponent as RiskMap } from './classic_map.svg';

const playerColors = ['red', 'lightblue', 'lightgreen', 'yellow', 'pink', 'orange'];

// Predefined positions for each territory with slightly reduced scaling
const territoryPositions = {
    "Alaska": { x: 85, y: 60 },
    "Northwest Territory": { x: 190, y: 60 },
    "Greenland": { x: 455, y: 20 },
    "Alberta": { x: 160, y: 105 },
    "Ontario": { x: 240, y: 105 },
    "Quebec": { x: 323, y: 100 },
    "Western United States": { x: 115, y: 155 },
    "Eastern United States": { x: 225, y: 190 },
    "Central America": { x: 150, y: 250 },
    "Venezuela": { x: 270, y: 315 },
    "Peru": { x: 270, y: 410 },
    "Brazil": { x: 340, y: 385 },
    "Argentina": { x: 290, y: 505 },
    "North Africa": { x: 550, y: 265 },
    "Egypt": { x: 640, y: 225 },
    "East Africa": { x: 720, y: 310 },
    "Congo": { x: 650, y: 345 },
    "South Africa": { x: 655, y: 435 },
    "Madagascar": { x: 745, y: 435 },
    "Western Europe": { x: 520, y: 145 },
    "Southern Europe": { x: 635, y: 155 },
    "Northern Europe": { x: 630, y: 115 },
    "Great Britain": { x: 520, y: 110 },
    "Scandinavia": { x: 610, y: 65 },
    "Ukraine": { x: 705, y: 95 },
    "Iceland": { x: 490, y: 75 },
    "Middle East": { x: 740, y: 195 },
    "Afghanistan": { x: 810, y: 135 },
    "Ural": { x: 800, y: 75 },
    "Siberia": { x: 865, y: 55 },
    "Yakutsk": { x: 970, y: 55 },
    "Irkutsk": { x: 950, y: 100 },
    "Kamchatka": { x: 1105, y: 55 },
    "Mongolia": { x: 970, y: 145 },
    "Japan": { x: 1135, y: 185 },
    "China": { x: 980, y: 205 },
    "India": { x: 880, y: 235 },
    "Siam": { x: 975, y: 265 },
    "Indonesia": { x: 1030, y: 340 },
    "New Guinea": { x: 1150, y: 345 },
    "Western Australia": { x: 1030, y: 475 },
    "Eastern Australia": { x: 1130, y: 450 }
};

const GameBoard = () => {
    const [gameState, setGameState] = useState(null);
    const [error, setError] = useState(null);
    const [watchMode, setWatchMode] = useState(false);

    const fetchGameState = () => {
        axios
            .get('http://localhost:8000/game-state')
            .then((response) => {
                setGameState(response.data.game_state);
                setError(response.data.error);
            })
            .catch((error) => {
                setError(error.message);
            });
    };

    useEffect(() => {
        fetchGameState();
    }, []);

    useEffect(() => {
        if (watchMode) {
            const interval = setInterval(() => {
                fetchGameState();
            }, 200);

            return () => clearInterval(interval);
        }
    }, [watchMode]);

    const toggleWatchMode = () => {
        setWatchMode(!watchMode);
    };

    useEffect(() => {
        if (gameState) {
            // Get the root SVG element or a group element where text will be appended
            const svgElement = document.querySelector('.risk-map');
            if (!svgElement) {
                console.error('SVG element not found.');
                return;
            }
    
            // Clear any existing text elements
            svgElement.querySelectorAll('text, circle').forEach(el => el.remove());
    
            gameState.players.forEach((player, playerIndex) => {
                player.territories.forEach((territory) => {
                    // Use attribute selector to handle IDs with spaces
                    const territoryElements = document.querySelectorAll(`[id="${territory}"]`);
    
                    if (territoryElements.length > 0) {
                        territoryElements.forEach((territoryElement) => {
                            territoryElement.setAttribute('fill', playerColors[playerIndex % playerColors.length]);
                            territoryElement.setAttribute('stroke', 'white');
                            territoryElement.setAttribute('stroke-width', '1');
                        });
    
                        // Use predefined positions for the text
                        const position = territoryPositions[territory];
                        if (position) {
                            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            text.setAttribute('x', position.x);
                            text.setAttribute('y', position.y);
                            text.setAttribute('fill', 'black');
                            text.setAttribute('font-size', '12');
                            text.setAttribute('font-weight', '600');
                            text.setAttribute('text-anchor', 'middle');
                            text.setAttribute('dominant-baseline', 'middle');
                            
                            // Create tspan elements for line breaks
                            const tspan1 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            tspan1.setAttribute('x', position.x);
                            tspan1.setAttribute('dy', '1.2em'); // Vertical offset for first line
                            tspan1.textContent = territory;
    
                            const tspan2 = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                            tspan2.setAttribute('x', position.x);
                            tspan2.setAttribute('dy', '1.2em'); // Vertical offset for second line
                            tspan2.textContent = player.armies[territory];
    
                            text.appendChild(tspan1);
                            text.appendChild(tspan2);
                            
                            // Append the text element to the SVG
                            svgElement.appendChild(text);
                        } else {
                            console.warn(`Position not defined for territory: ${territory}`);
                        }
                    } else {
                        console.warn(`Territory not found: ${territory}`);
                    }
                });
            });
        }
    }, [gameState]);
    
    if (error) {
        return <div>Error: {error}</div>;
    }
    
    if (!gameState) {
        return <div>Loading...</div>;
    }
    
    const currentPlayer =
        gameState.players && gameState.players[gameState.current_turn];
    
    return (
        <div className="game-container">
            <div className="left-column">
                <div className="header">
                    <h2>Round: {gameState.round}</h2>
                    <h2>
                    Active Player:{' '}
                        <span
                            style={{
                                background: playerColors[gameState.current_turn % playerColors.length],
                                color: 'black'
                            }}
                        >
                            {gameState.current_player}
                        </span>
                    </h2>
                    <h2>Turn Phase: {gameState.turn_phase}</h2>
                    <label className="watch-mode-toggle">
                        <input
                            type="checkbox"
                            checked={watchMode}
                            onChange={toggleWatchMode}
                        />
                        Observer Mode
                    </label>
                </div>
                <div className="map-container">
                    <RiskMap className="risk-map" />
                </div>
            </div>
            <div className="right-column">
                <div className="game-info">
                    {currentPlayer && (
                        <div className="player-cards">
                            <h3>Cards</h3>
                            <ul>
                                {currentPlayer.cards.map((card, index) => (
                                    <li key={index}>
                                        {card.territory
                                            ? `${card.territory} (${card.kind})`
                                            : `(${card.kind})`}
                                    </li>
                                ))}
                            </ul>
                            <hr class="solid"></hr>
                        </div>
                    )}
                    <PossibleActions
                        gameState={gameState}
                        fetchGameState={fetchGameState}
                        setError={setError}
                    />
                </div>
            </div>
        </div>
    );
};

export default GameBoard;


PossibleActions.css:
====================

.actions-container ul {
    list-style-type: none;
    padding: 0;
}

.actions-container li {
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    background-color: #f9f9f9;
}

.actions-container .action-content {
    display: flex;
    flex-direction: column;
}

.actions-container .action-text {
    flex-grow: 1;
}

.actions-container .action-controls {
    display: flex;
    justify-content: space-between;
    margin-top: 5px;
}

.actions-container select {
    margin-right: 10px;
}

.actions-container button {
    height: 25.5px;
    padding: 5px 10px;
    background-color: #ca4203;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

.actions-container button:hover {
    background-color: #e84c03;
}

.actions-container .arrow {
    display: block;
    text-align: left;
    margin: 5px 0;
    font-size: 20px;
    line-height: 1;
}

.actions-container .action-card {
    position: relative;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 8px;
    padding: 10px;
    background-color: #f9f9f9;
}

.actions-container .probability {
    position: absolute;
    top: 10px;
    right: 10px;
    font-size: 0.8rem;
    background-color: #fffa;
    padding: 2px 5px;
    border-radius: 5px;
    color: #000;
    font-weight: bold;
}


PossibleActions.js:
===================

import React, { useEffect, useState } from 'react';
import axios from 'axios';
import './PossibleActions.css';

const PossibleActions = ({ gameState, fetchGameState, setError }) => {
    const [numUnits, setNumUnits] = useState(1);
    const [isAuto, setIsAuto] = useState(true);
    useEffect(() => {
        if (gameState.turn_phase === 'Attack') {
            setIsAuto(true);
        }
    }, [gameState.turn_phase]);

    const handleAction = (action) => {
        let request = null;

        switch (action.type) {
            case 'Reinforce':
                request = axios.post('http://localhost:8000/reinforce', {
                    player_id: gameState.current_turn,
                    territory: action.territory,
                    num_armies: numUnits,
                });
                break;
            case 'Attack':
                request = axios.post('http://localhost:8000/attack', {
                    player_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_dice: isAuto ? 3 : numUnits, // Use 3 dice if "Auto" is selected
                    repeat: isAuto ? true : false, // Set repeat to true if "Auto" is selected
                });
                break;
            case 'Fortify':
                request = axios.post('http://localhost:8000/fortify', {
                    player_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_armies: numUnits,
                });
                break;
            case 'MoveArmies':
                request = axios.post('http://localhost:8000/move_armies', {
                    player_id: gameState.current_turn,
                    from_territory: action.from,
                    to_territory: action.to,
                    num_armies: numUnits,
                });
                break;
            case 'TradeCards':
                request = axios.post('http://localhost:8000/trade_cards', {
                    player_id: gameState.current_turn,
                    card_indices: action.card_indices,
                });
                break;
            case 'End Phase':
                request = axios.post('http://localhost:8000/advance_phase');
                break;
            default:
                console.error('Unknown action type:', action.type);
        }

        if (request) {
            request
                .then((response) => {
                    fetchGameState();
                    setNumUnits(1);
                    setIsAuto(false); // Reset "Auto" selection after action
                })
                .catch((error) => {
                    setError(error.message);
                });
        }
    };

    const findProbability = (from, to) => {
        const prob = gameState.conquer_probs.find(
            ([probFrom, probTo]) => probFrom === from && probTo === to
        );
        return prob ? parseFloat(prob[2].toFixed(2)) : 0;
    };

    const actionGroups = gameState.possible_actions.reduce((groups, action) => {
        if (typeof action === 'string') {
            if (!groups['End Phase']) {
                groups['End Phase'] = [];
            }
            groups['End Phase'].push(action);
        } else {
            const actionType = Object.keys(action)[0];
            if (!groups[actionType]) {
                groups[actionType] = [];
            }
            groups[actionType].push(action[actionType]);
        }
        return groups;
    }, {});

    // Sort the attack actions based on probability from highest to lowest
    if (actionGroups['Attack']) {
        actionGroups['Attack'].sort((a, b) => {
            const probA = findProbability(a.from, a.to);
            const probB = findProbability(b.from, b.to);
            return probB - probA; // Sort descending
        });
    }

    const currentPlayer = gameState.players[gameState.current_turn];

    return (
        <div className="actions-container">
            {Object.keys(actionGroups).map((actionType, index) => (
                <div key={index}>
                    <h3>{actionType === 'AdvancePhase' ? 'End Phase' : actionType}</h3>
                    <ul>
                        {actionGroups[actionType].map((actionDetails, idx) => (
                            <li key={idx} className="action-card">
                                <div className="action-content">
                                    <div className="action-text">
                                        {typeof actionDetails === 'string' ? (
                                            <span>{actionDetails}</span>
                                        ) : (
                                            Object.keys(actionDetails).map((key, idy) => (
                                                key !== 'max_dice' && key !== 'max_armies' && key !== 'card_indices' && (
                                                    <div key={idy}>
                                                        {key === 'from' || key === 'to' ? (
                                                            <span>
                                                                {actionDetails[key]}
                                                                {key === 'from' && (
                                                                    <span className="arrow">
                                                                        &darr;
                                                                    </span>
                                                                )}
                                                            </span>
                                                        ) : (
                                                            key !== 'type' && <span>{actionDetails[key]}</span>
                                                        )}
                                                    </div>
                                                )
                                            ))
                                        )}
                                    </div>
                                    {actionType === 'Attack' && (
                                        <div className="probability">
                                            {findProbability(actionDetails.from, actionDetails.to).toFixed(2)}%
                                        </div>
                                    )}
                                    <div className="action-controls">
                                        {typeof actionDetails !== 'string' && (
                                            (actionType === 'Reinforce' ||
                                                actionType === 'Attack' ||
                                                actionType === 'Fortify' ||
                                                actionType === 'MoveArmies') && (
                                                <select
                                                    value={isAuto ? 'auto' : numUnits}
                                                    onChange={(e) => {
                                                        const value = e.target.value;
                                                        if (value === 'auto') {
                                                            setIsAuto(true);
                                                        } else {
                                                            setIsAuto(false);
                                                            setNumUnits(parseInt(value));
                                                        }
                                                    }}
                                                >
                                                    {actionType === 'Attack' && (
                                                        <option value="auto">Auto</option>
                                                    )}
                                                    {Array.from(
                                                        {
                                                            length:
                                                                actionType === 'Attack'
                                                                    ? actionDetails.max_dice
                                                                    : actionDetails.max_armies,
                                                        },
                                                        (_, i) => i + 1
                                                    ).map((num) => (
                                                        <option key={num} value={num}>
                                                            {num} {actionType === 'Attack' ? 'Dice' : 'Armies'}
                                                        </option>
                                                    ))}
                                                </select>
                                            )
                                        )}
                                        {actionType === 'TradeCards' ? (
                                            <div className="cards">
                                                {actionDetails.card_indices.map((cardIndex) => (
                                                    <span key={cardIndex}>
                                                        {currentPlayer.cards[cardIndex].territory} ({currentPlayer.cards[cardIndex].kind})
                                                    </span>
                                                ))}
                                            </div>
                                        ) : null}
                                        <button
                                            onClick={() =>
                                                handleAction({
                                                    ...actionDetails,
                                                    type: actionType,
                                                })
                                            }
                                        >
                                            Execute
                                        </button>
                                    </div>
                                </div>
                            </li>
                        ))}
                    </ul>
                </div>
            ))}
        </div>
    );
};

export default PossibleActions;


index.css:
==========

body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-image: url('./background1920.jpg'); /* Add this line */
  background-size: cover; /* Ensure the background image covers the entire container */
  background-position: center; /* Center the background image */

}
body::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 248, 243, 0.85); /* Change the color and opacity as needed */
  z-index: -1; /* Ensure the overlay is behind the content */
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}



index.js:
=========

import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);